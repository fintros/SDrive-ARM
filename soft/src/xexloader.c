/*
 * ---------------------------------------------------------------------------
 * -- (c) 2020 Alexey Spirkov
 * -- I am happy for anyone to use this for non-commercial use.
 * -- If my verilog/vhdl/c files are used commercially or otherwise sold,
 * -- please contact me for explicit permission at me _at_ alsp.net.
 * -- This applies for source and binary form and derived works.
 * ---------------------------------------------------------------------------
 */

#include "xexloader.h"
#include "diskemu.h"
#include "sio.h"
#include "gpio.h"
#include "dprint.h"

//
// XEX Bootloader
// Bob!k & Raster, C.P.U., 2008
//
unsigned char boot_xex_loader[179] = {
	0x72,0x02,0x5f,0x07,0xf8,0x07,0xa9,0x00,0x8d,0x04,0x03,0x8d,0x44,0x02,0xa9,0x07,
	0x8d,0x05,0x03,0xa9,0x70,0x8d,0x0a,0x03,0xa9,0x01,0x8d,0x0b,0x03,0x85,0x09,0x60,
	0x7d,0x8a,0x48,0x20,0x53,0xe4,0x88,0xd0,0xfa,0x68,0xaa,0x8c,0x8e,0x07,0xad,0x7d,
	0x07,0xee,0x8e,0x07,0x60,0xa9,0x93,0x8d,0xe2,0x02,0xa9,0x07,0x8d,0xe3,0x02,0xa2,
	0x02,0x20,0xda,0x07,0x95,0x43,0x20,0xda,0x07,0x95,0x44,0x35,0x43,0xc9,0xff,0xf0,
	0xf0,0xca,0xca,0x10,0xec,0x30,0x06,0xe6,0x45,0xd0,0x02,0xe6,0x46,0x20,0xda,0x07,
	0xa2,0x01,0x81,0x44,0xb5,0x45,0xd5,0x43,0xd0,0xed,0xca,0x10,0xf7,0x20,0xd2,0x07,
	0x4c,0x94,0x07,0xa9,0x03,0x8d,0x0f,0xd2,0x6c,0xe2,0x02,0xad,0x8e,0x07,0xcd,0x7f,
	0x07,0xd0,0xab,0xee,0x0a,0x03,0xd0,0x03,0xee,0x0b,0x03,0xad,0x7d,0x07,0x0d,0x7e,
	0x07,0xd0,0x8e,0x20,0xd2,0x07,0x6c,0xe0,0x02,0x20,0xda,0x07,0x8d,0xe0,0x02,0x20,
	0xda,0x07,0x8d,0xe1,0x02,0x2d,0xe0,0x02,0xc9,0xff,0xf0,0xed,0xa9,0x00,0x8d,0x8e,
	0x07,0xf0,0x82 };
//  Relocation table do not needed - just replace all entrances of 0x07
//  (Should be exactly 20 0x07 bytes)


int ReadXEX(file_t* pDisk, unsigned char* buffer, unsigned short sector)
{
    // cleanup buffer
    memset(buffer, 0, XEX_SECTOR_SIZE);
    
    if(sector <= 2) // bootloader
    {
        unsigned char* pBase = &(boot_xex_loader[(sector-1) * XEX_SECTOR_SIZE]);
        for(int i = 0; i < XEX_SECTOR_SIZE; i++)
        {
            unsigned char src = pBase[i];
            if(src == 0x07)
                src += shared_parameters.bootloader_relocation;
            buffer[i] = src;            
        }
    }
    else if(sector >= 0x171)    // Bob!k & Raster, C.P.U., 2008 XEX Bootloader
    {
        unsigned long real_sector = sector - 0x171;
		unsigned short proceeded_bytes = faccess_offset(pDisk, FILE_ACCESS_READ,real_sector*(XEX_SECTOR_SIZE-3), buffer, XEX_SECTOR_SIZE-3);

		if(proceeded_bytes<(XEX_SECTOR_SIZE-3))
			sector=0; //it was last sector
		else
			sector++; //next sector

		buffer[XEX_SECTOR_SIZE-3]=((sector)>>8);
		buffer[XEX_SECTOR_SIZE-2]=((sector)&0xff);
		buffer[XEX_SECTOR_SIZE-1]=proceeded_bytes;
        
    }
    else
    {
        dprint("Unsble to read XEX sector 0x%x\r\n", sector);
        while(1); // TODO: process correcly - hangs for a while;   
    }
    
    USART_Send_cmpl_and_buffer_and_check_sum(buffer, XEX_SECTOR_SIZE);
        
    return 0;
}
